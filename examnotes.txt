Noah:
MSTs:

starter med undirected graph
vil finde n-1 mindste kanter der udgør MST
ikke n-1 korteste kanter, nødvendigvis, men mindste totale vægt

undergraf:
    delgraf der består af nogle knuder og nogle kanter
træ:
    en delgraf uden kredse, ingen cykler

MST, kun en vej fra en knude en hvilken som helst anden

mindst udspændende træer:
   delgraf, træ, der udspænder alle knuder


cut kan bruges til at finde et MST
    vi "skærer" igennem et sæt, og et MST vil blive udgjort af de mindste kanter fra alle kombinationer af dette, må ikke skære igennem en markeret edge

Kruskal:
    går igennem array af edges sorteret efter vægt
    tilføjer edge til MST hvis mindst en af knuderne ikke er markeret
    bevis for korrekthed:
          bevis løkkeinvarianten, i dette tilfælde:
                skal tilfredsstille træstruktur
    O(Elog(E))
    datastruktur:
        disjoint sets

Æmilie:
MST

et snit deler punktmængden i to ikke-tomme delmængder
krydsende kant: har endepunkt i begge delmængder
et let kant: mindste af de krydsende kanter

et snit må ikke have tidligere markeret kant som krydsende kant

prims kan implementeres som min-hob
      make
      extract-min
      decrease-key

Kruskal: specialtilfælde af generic
sorterer efter vægt O(mlog(m))
man tilføjer altid kant uden at lukke en kreds
datastruktur:
        disjunkte mængder
lav mængde for hver knude
Create O(1)
link O(1)
find O(log(m))

korrekthedsbevis:
    definer lykkeinvariant
    snak om det generelle tilfælde

Jonas:
Binære søgetræer:
   definerer et søgetræ, understøtter funktioner
   binært søgetræ:
      venstre barn er <= forælder
      højre er > forælder
      make
      delete
      lookup
      insert
   alle er begrænset af højden på træet

man kan kun rykke direkte forgænger eller forfølger op i roden efter delete

hvis hvordan en funktion virker

bevis højden af træet
stærk induktion til bevis af højden

bevis at højden bliver opretholdt vha. rød/sort markering
rod skal altid være sort

fortæl hvad en rotation er
